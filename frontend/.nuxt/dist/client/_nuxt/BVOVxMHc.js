import{d as c,x as k,af as R,N,Q as j,ab as x,ai as l,aj as P,Y as g,ak as S,al as _,u as h,am as d,h as y,n as w,an as O,J as T,Z as v,ao as A,ap as B}from"./DnNEn_NX.js";const E=c({name:"LayoutLoader",inheritAttrs:!1,props:{name:String,layoutProps:Object},setup(t,n){return()=>y(l[t.name],t.layoutProps,n.slots)}}),C={name:{type:[String,Boolean,Object],default:null},fallback:{type:[String,Object],default:null}},W=c({name:"NuxtLayout",inheritAttrs:!1,props:C,setup(t,n){const o=k(),u=g(d),e=!u||u===R()?P():u,a=N(()=>{let s=h(t.name)??(e==null?void 0:e.meta.layout)??"default";return s&&!(s in l)&&t.fallback&&(s=h(t.fallback)),s}),i=j();n.expose({layoutRef:i});const r=o.deferHydration();if(o.isHydrating){const s=o.hooks.hookOnce("app:error",r);x().beforeEach(s)}let f;return()=>{const s=a.value&&a.value in l,p=(e==null?void 0:e.meta.layoutTransition)??S,b=f;return f=a.value,_(s&&p,{default:()=>y(O,{suspensible:!0,onResolve:()=>{w(r)}},{default:()=>y(H,{layoutProps:T(n.attrs,{ref:i}),key:a.value||void 0,name:a.value,shouldProvide:!t.name,isRenderingNewLayout:m=>m!==b&&m===a.value,hasTransition:!!p},n.slots)})}).default()}}}),H=c({name:"NuxtLayoutProvider",inheritAttrs:!1,props:{name:{type:[String,Boolean]},layoutProps:{type:Object},hasTransition:{type:Boolean},shouldProvide:{type:Boolean},isRenderingNewLayout:{type:Function,required:!0}},setup(t,n){const o=t.name;t.shouldProvide&&v(B,{isCurrent:e=>o===(e.meta.layout??"default")});const u=g(d);if(u&&u===R()){const e=P(),a={};for(const i in e){const r=i;Object.defineProperty(a,r,{enumerable:!0,get:()=>t.isRenderingNewLayout(t.name)?e[r]:u[r]})}v(d,A(a))}return()=>{var e,a;return!o||typeof o=="string"&&!(o in l)?(a=(e=n.slots).default)==null?void 0:a.call(e):y(E,{key:o,layoutProps:t.layoutProps,name:o},n.slots)}}});export{W as _};
